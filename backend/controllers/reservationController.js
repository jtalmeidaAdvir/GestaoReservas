const { Reservation, Trip, Bus, BlackList,sequelize } = require("../models");
const { Op, Sequelize } = require("sequelize");

let io; // Vari√°vel global para armazenar io

exports.setSocketIO = (socketIo) => {
    io = socketIo;
};



// Buscar a √∫ltima reserva para obter o maior n√∫mero j√° usado
exports.getLastReservation = async (req, res) => {
    try {
        const lastReservation = await Reservation.findOne({
            order: [["reserva", "DESC"]], 
        });

        const lastReservaNumber = lastReservation ? parseInt(lastReservation.reserva, 10) : 0;
        res.json({ reserva: String(lastReservaNumber).padStart(4, "0") });
    } catch (error) {
        console.error("üî• Erro ao buscar √∫ltima reserva:", error);
        res.status(500).json({ error: "Erro ao buscar √∫ltima reserva" });
    }
};




exports.createReservation = async (req, res) => {
    try {
        const { tripId, preco, precoBase, moeda, entrada, nomePassageiro, apelidoPassageiro, saida, volta, telefone, email, obs, lugar, carro, reserva,valorCarro, valorVolume, impresso, bilhete, createdBy } = req.body;

        console.log(`üîπ Tentando criar reserva N¬∫ ${reserva} para o lugar ${lugar}`);

        const existingReservation = await Reservation.findOne({ where: { reserva, tripId } });

        if (existingReservation) {
            console.warn(`‚ö†Ô∏è Reserva N¬∫ ${reserva} j√° existe para esta viagem!`);
            return res.status(400).json({ error: "N√∫mero de reserva j√° existe nesta viagem." });
        }

        const newReservation = await Reservation.create({
            tripId, lugar, reserva, valorCarro, valorVolume, preco, precoBase, moeda, entrada, nomePassageiro, apelidoPassageiro, saida, volta, telefone, email, obs, carro, createdBy
        });

        console.log("‚úÖ Nova reserva criada:", newReservation.dataValues);

        if (io) {
            io.emit("reservationUpdated", { tripId });
        } else {
            console.warn("‚ö†Ô∏è WebSocket io n√£o est√° definido!");
        }

        res.status(201).json(newReservation);
    } catch (error) {
        console.error("üî• Erro ao criar reserva:", error);
        res.status(500).json({ error: "Erro ao criar reserva" });
    }
};


// Obter todas as reservas de uma viagem espec√≠fica
exports.getReservationsByTrip = async (req, res) => {
    try {
        const { tripId } = req.params;
        const reservations = await Reservation.findAll({ where: { tripId: Number(req.params.tripId) } });

        res.json(reservations);
    } catch (error) {
        console.error("Erro ao listar reservas:", error);
        res.status(500).json({ error: "Erro ao listar reservas" });
    }
};

exports.updateReservation = async (req, res) => {
    try {
        const { id } = req.params;
        const { updatedBy, ...updateData } = req.body; // Extraindo updatedBy do body

        console.log("üîç Tentando atualizar reserva com ID:", id);

        const reservation = await Reservation.findByPk(id);
        if (!reservation) {
            console.error("‚ùå Reserva n√£o encontrada:", id);
            return res.status(404).json({ error: "Reserva n√£o encontrada" });
        }

        await reservation.update({ 
            ...updateData,
            updatedBy // Definir o updatedBy com o utilizador que fez a altera√ß√£o
        });

        console.log("‚úÖ Reserva atualizada:", reservation.dataValues);

        // üî• Emitir evento WebSocket para todos os clientes
        req.io.emit("reservationUpdated", { tripId: reservation.tripId });

        res.json({ message: "Reserva atualizada", reservation });
    } catch (error) {
        console.error("üî• Erro ao atualizar reserva:", error);
        res.status(500).json({ error: "Erro ao atualizar reserva" });
    }
};




// Buscar reserva pelo campo "reserva"
exports.getReservationByReserva = async (req, res) => {
    try {
        const reservaNumber = req.params.reserva;
    
        // Inclui a rela√ß√£o com Trip
        const reservation = await Reservation.findOne({
          where: { reserva: reservaNumber },
          include: [{ model: Trip }] // ou { model: Trip, as: "trip" } se tiveres um alias
        });
    
        if (!reservation) {
          return res.status(404).json({ error: "Reserva n√£o encontrada" });
        }
    
        // Agora `reservation` vem com a Trip associada dentro de `reservation.Trip`
        res.json(reservation);
      } catch (error) {
        console.error("Erro ao buscar reserva:", error);
        res.status(500).json({ error: "Erro interno do servidor" });
      }
    };


    // Buscar reserva pelo campo "telefone"
exports.getReservationByPhone = async (req, res) => {
  try {
      const telefone = req.params.telefone;

      const reservation = await Reservation.findAll({
          where: { telefone },
          include: [{ model: Trip }]
      });

      if (!reservation) {
          return res.status(404).json({ error: "Reserva n√£o encontrada" });
      }

      res.json(reservation);
  } catch (error) {
      console.error("Erro ao buscar reserva por telefone:", error);
      res.status(500).json({ error: "Erro interno do servidor" });
  }
};


// üîπ Buscar reserva pelo nome + apelido do passageiro
exports.getReservationByPassengerName = async (req, res) => {
  try {
      const { nome, apelido } = req.params;

      const reservations = await Reservation.findAll({
          where: {
              [Op.and]: [
                  { nomePassageiro: { [Op.like]: `%${nome}%` } },
                  { apelidoPassageiro: { [Op.like]: `%${apelido}%` } }
              ]
          },
          include: [{ model: Trip }]
      });

      if (!reservations || reservations.length === 0) {
          return res.status(404).json({ error: "Nenhuma reserva encontrada para este passageiro" });
      }

      res.json(reservations);
  } catch (error) {
      console.error("Erro ao buscar reserva por nome de passageiro:", error);
      res.status(500).json({ error: "Erro interno do servidor" });
  }
};


// Atualizar apenas o lugar de uma reserva espec√≠fica
exports.updateReservationPlace = async (req, res) => {
    try {
        const { reserva } = req.params;
        const { lugar, updatedBy } = req.body;

        console.log(`üîÑ Tentando atualizar a reserva N¬∫ ${reserva} para o lugar ${lugar}...`);

        const reservation = await Reservation.findOne({ where: { reserva } });
        if (!reservation) {
            console.warn(`‚ùå Reserva N¬∫ ${reserva} n√£o encontrada.`);
            return res.status(404).json({ error: "Reserva n√£o encontrada" });
        }

        await reservation.update({ 
            lugar,
            updatedBy // Registar quem fez a atualiza√ß√£o
        });

        console.log(`‚úÖ Lugar atualizado para ${lugar} na reserva N¬∫ ${reserva}.`);

        // Emitir evento WebSocket para atualizar no frontend
        req.io.emit("reservationUpdated", { tripId: reservation.tripId });

        res.json({ message: "Lugar atualizado com sucesso", reservation });
    } catch (error) {
        console.error("üî• Erro ao atualizar lugar da reserva:", error);
        res.status(500).json({ error: "Erro ao atualizar lugar da reserva" });
    }
};




// controllers/reservationController.js

exports.createReturnReservation = async (req, res) => {
    try {
        const {
            reservaIda,
            origemIda,
            destinoIda,
            dataVolta,
            saidaIda,
            nomePassageiro,
            apelidoPassageiro,
            telefone,
            email,
            obs,
            preco,
            precoBase,
            moeda,
            carro,
            valorCarro,
            valorVolume,
            impresso,
            bilhete,
            createdBy
        } = req.body;

        // üîπ Usar o mesmo n√∫mero de reserva para a viagem de volta
        const reservaVolta = reservaIda; // ‚úÖ Mesma reserva

        // üîπ Encontrar ou criar a viagem de regresso
        const [tripRegresso, tripCreated] = await Trip.findOrCreate({
            where: { origem: destinoIda, destino: origemIda, dataviagem: dataVolta },
            defaults: { origem: destinoIda, destino: origemIda, dataviagem: dataVolta }
        });

        // üîπ Criar a reserva de volta, permitindo duplica√ß√£o no mesmo n√∫mero de reserva
        const newReturnReservation = await Reservation.create({
            tripId: tripRegresso.id,
            reserva: reservaVolta, // ‚úÖ Agora mant√©m-se igual
            preco,
            precoBase,
            moeda,
            entrada: saidaIda, 
            saida: dataVolta,  
            volta: null,        
            nomePassageiro,
            apelidoPassageiro,
            telefone,
            email,
            obs,
            carro,
            lugar: 0, // Define um lugar dispon√≠vel mais tarde
            valorCarro,
            valorVolume,
            impresso,
            bilhete,
            createdBy
        });

        console.log(`‚úÖ Reserva de regresso criada com o mesmo n√∫mero: ${reservaVolta}`);

        req.io.emit("reservationUpdated", { tripId: tripRegresso.id });

        return res.status(201).json({
            message: "Reserva de regresso criada com sucesso",
            tripRegresso,
            newReturnReservation
        });

    } catch (error) {
        console.error("üî• Erro ao criar reserva de regresso:", error);
        return res.status(500).json({ error: "Erro ao criar reserva de regresso" });
    }
};

  

  exports.ReturnReservationsOfBus = async (req, res) => {
    try {
        const { tripId } = req.params;

        // Buscar a viagem para obter o n√∫mero total de lugares do autocarro
        const trip = await Trip.findOne({
            where: { id: tripId },
            include: [{ model: Bus, attributes: ["nlugares"] }] // Obter n√∫mero de lugares do autocarro
        });

        if (!trip || !trip.Bus) {
            return res.status(404).json({ message: "Viagem ou autocarro n√£o encontrados." });
        }

        const totalSeats = trip.Bus.nlugares;
        console.log(`üîç Viagem ${tripId} tem ${totalSeats} lugares.`);

        // Buscar reservas j√° existentes para esta viagem
        const reservations = await Reservation.findAll({
            where: { tripId: Number(req.params.tripId) },
            attributes: ["lugar"]
        });

        // Criar uma lista de lugares ocupados
        const occupiedSeats = reservations.map(reservation => reservation.lugar);
        console.log(`‚úÖ Lugares ocupados: ${occupiedSeats}`);

        // Criar lista de lugares dispon√≠veis
        const allSeats = Array.from({ length: totalSeats }, (_, i) => i + 1);
        const freeSeats = allSeats.filter(seat => !occupiedSeats.includes(seat));

        console.log(`‚úÖ Lugares livres: ${freeSeats}`);

        res.json({ freeSeats });
    } catch (error) {
        console.error("üî• Erro ao buscar lugares dispon√≠veis:", error);
        res.status(500).json({ message: "Erro no servidor ao buscar lugares dispon√≠veis.", error: error.message });
    }
};





// controllers/reservationController.js

exports.deleteReservation = async (req, res) => {
    const { reserva } = req.params;
  
    try {
      let tripIdDeleted = null;              // ‚ûä vari√°vel para usar depois da transac√ß√£o
  
      await sequelize.transaction(async (t) => {
        const reservation = await Reservation.findOne({
          where: { reserva },
          transaction: t,
        });
  
        if (!reservation) {
          // atira erro para ser apanhado fora da transaction
          throw new Error("NOT_FOUND");
        }
  
        tripIdDeleted = reservation.tripId;  // ‚ûã guardar antes de destruir
  
        // Clonar dados sem o id
        const dataToBlacklist = { ...reservation.get({ plain: true }) };
        delete dataToBlacklist.id;
        dataToBlacklist.deletedAt = new Date();
  
        await BlackList.create(dataToBlacklist, { transaction: t });
        await reservation.destroy({ transaction: t });
      });
  
      // ‚ûå Notificar via WebSocket se tivermos um tripId v√°lido
      if (io && tripIdDeleted) {
        io.emit("reservationUpdated", { tripId: tripIdDeleted });
      }
  
      return res.json({
        message: `Reserva ${reserva} eliminada e movida para ListaNegra.`,
      });
    } catch (error) {
      if (error.message === "NOT_FOUND") {
        return res.status(404).json({ error: "Reserva n√£o encontrada" });
      }
      console.error("üî• Erro ao mover para ListaNegra:", error);
      return res.status(500).json({ error: "Erro ao eliminar reserva" });
    }
  };
  

exports.getOpenReturnReservations = async (req, res) => {
    try {
        const reservations = await Reservation.findAll({
            where: Sequelize.where(
                Sequelize.fn("LOWER", Sequelize.col("volta")),
                {
                    [Op.like]: "%aberto%"
                }
            ),
            include: [{ model: Trip }] // Opcional: inclui a viagem associada
        });

        if (!reservations || reservations.length === 0) {
            return res.status(404).json({ message: "Nenhuma reserva com 'volta' em aberto encontrada." });
        }

        res.json(reservations);
    } catch (error) {
        console.error("üî• Erro ao buscar reservas com 'volta' em aberto:", error);
        res.status(500).json({ error: "Erro ao buscar reservas com volta em aberto" });
    }
};



exports.getAllReservations = async (req, res) => {
    try {
      const reservations = await Reservation.findAll({
        include: [{ model: Trip }], // Inclui dados da viagem
        order: [["createdAt", "DESC"]] // ou ["dataviagem", "DESC"] se preferires
      });
      res.json(reservations);
    } catch (err) {
        console.error("üî• ERRO AO BUSCAR RESERVAS:");
        console.error(err.message);       // Erro principal
        console.error(err.original);      // Erro do SQL Server (RequestError)
        res.status(500).json({ erro: "Erro ao buscar reservas", detalhe: err.message });
      }
  };
  


exports.getLastTicket = async (req, res) => {
    try {
      // L√™ o maior valor da coluna "bilhete" na tabela "reservations"
      const lastTicket = await Reservation.max("bilhete"); 
      // Se nunca existiu nenhum bilhete, retorna 0
      const lastBilhete = lastTicket || 0;
  
      return res.json({ bilhete: lastBilhete });
    } catch (error) {
      console.error("Erro ao buscar √∫ltimo bilhete:", error);
      return res.status(500).json({
        error: "Erro ao buscar √∫ltimo bilhete"
      });
    }
  };
  